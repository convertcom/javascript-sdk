// This file is auto-generated by @hey-api/openapi-ts

/**
 * Base Audience object
 */
export type ConfigAudience = {
    /**
     * Audience ID
     */
    id?: string;
    /**
     * Audience unique key
     */
    key?: string;
    /**
     * Audience Name
     */
    name?: string;
    type?: ConfigAudienceTypes;
    rules?: ((RuleObject) | null);
};

/**
 * Type of the Audience. Can be one of the following: `permanent`, `transient`. For full-stack projects, `transient` is the only valid option, the rest will be ignored.
 * * **permanent** - A permanent audience is one that is checked only at the time the user is being bucketed into the experience
 * * **transient** - A transient audience is one that is checked every time the user is being bucketed into the experience
 *
 */
export type ConfigAudienceTypes = 'permanent' | 'transient';

/**
 * Type of the Audience. Can be one of the following: `permanent`, `transient`. For full-stack projects, `transient` is the only valid option, the rest will be ignored.
 * * **permanent** - A permanent audience is one that is checked only at the time the user is being bucketed into the experience
 * * **transient** - A transient audience is one that is checked every time the user is being bucketed into the experience
 *
 */
export const ConfigAudienceTypes = {
    PERMANENT: 'permanent',
    TRANSIENT: 'transient'
} as const;

export type PageNumber = {
    /**
     * The page number for paginated results. For example, if `results_per_page` is 30, `page: 2` will retrieve items 31-60.
     * Defaults to 1 if not specified.
     *
     */
    page?: number;
};

export type Pagination = {
    /**
     * The current page number being displayed from the paginated set.
     */
    current_page?: number;
    /**
     * The total number of items available across all pages for the current filter criteria.
     */
    items_count?: number;
    /**
     * The number of items included in the current page of results (matches `results_per_page` from the request).
     */
    items_per_page?: number;
    /**
     * The total number of pages available for the current filter criteria and `results_per_page` setting.
     */
    pages_count?: number;
};

export type ResultsPerPage = {
    /**
     * Specifies the maximum number of items to return in a single page of results.
     * Used for pagination. Default is 30, maximum is 50.
     *
     */
    results_per_page?: (number) | null;
};

export type SortDirection = {
    /**
     * The direction for sorting the list results, based on the `sort_by` field.
     * - `asc`: Ascending order (e.g., A-Z, 1-10, oldest to newest).
     * - `desc`: Descending order (e.g., Z-A, 10-1, newest to oldest).
     * Defaults to `desc` (newest/highest first) if not specified.
     *
     */
    sort_direction?: ('asc' | 'desc') | null;
};

/**
 * The direction for sorting the list results, based on the `sort_by` field.
 * - `asc`: Ascending order (e.g., A-Z, 1-10, oldest to newest).
 * - `desc`: Descending order (e.g., Z-A, 10-1, newest to oldest).
 * Defaults to `desc` (newest/highest first) if not specified.
 *
 */
export type sort_direction = 'asc' | 'desc';

/**
 * The direction for sorting the list results, based on the `sort_by` field.
 * - `asc`: Ascending order (e.g., A-Z, 1-10, oldest to newest).
 * - `desc`: Descending order (e.g., Z-A, 10-1, newest to oldest).
 * Defaults to `desc` (newest/highest first) if not specified.
 *
 */
export const sort_direction = {
    ASC: 'asc',
    DESC: 'desc'
} as const;

export type OnlyCount = {
    /**
     * If set to `true` in a list request, the response will only contain the total count of matching items (`extra.pagination.items_count`)
     * and will not include the actual item data. Useful for quickly getting totals without fetching full datasets.
     *
     */
    onlyCount?: boolean;
};

export type Extra = {
    pagination?: Pagination;
};

export type BaseRule = {
    /**
     * The specific attribute or condition to evaluate. Examples: 'url', 'cookie', 'browser_name', 'js_condition', 'page_tag_product_price'.
     * The allowed `rule_type` values depend on whether the rule is for an Audience (which can use visitor and page content attributes if it's a 'segmentation' type) or a Location (typically URL or page tag based).
     *
     */
    rule_type: string;
};

export type BaseRuleWithStringValue = BaseRule & {
    /**
     * The value used to match against 'rule_type' using 'matching'
     */
    value?: string;
};

export type BaseRuleWithJsCodeValue = BaseRule & {
    /**
     * The JS code that would be executed when rule is checked. The return value of this JS code is what is gonna be matched
     *
     * against **true**(or **false** if **matching.negated = true** is provided)
     *
     */
    value?: string;
};

export type BaseRuleWithBooleanValue = BaseRule & {
    /**
     * The value used to match against 'rule_type' using 'matching'
     */
    value?: boolean;
};

export type BaseRuleWithNumericValue = BaseRule & {
    /**
     * The value used to match against 'rule_type' using 'matching'
     */
    value?: number;
};

export type BaseRuleWithCountryCodeValue = BaseRule & {
    /**
     * The 2 letter ISO country code used for matching
     */
    value?: string;
};

export type BaseRuleWithLanguageCodeValue = BaseRule & {
    /**
     * The 2 letter ISO language code used for matching
     */
    value?: string;
};

export type BaseRuleWithGoalTriggeredValue = BaseRule & {
    /**
     * ID of the goal used for matching
     */
    value?: number;
};

export type BaseRuleWithVisitorTypeValue = BaseRule & {
    /**
     * Type of the visitors
     */
    value?: 'new' | 'returning';
};

/**
 * Type of the visitors
 */
export type value = 'new' | 'returning';

/**
 * Type of the visitors
 */
export const value = {
    NEW: 'new',
    RETURNING: 'returning'
} as const;

export type BaseRuleWithExperienceBucketedValue = BaseRule & {
    /**
     * ID of the experience used for matching
     */
    value?: number;
};

export type BaseRuleWithSegmentBucketedValue = BaseRule & {
    /**
     * ID of the segment used for matching
     */
    value?: number;
};

export type BaseRuleWithDayOfWeekValue = BaseRule & {
    /**
     * Day of week used for matching
     */
    value?: number;
};

export type BaseRuleWithHourOfDayValue = BaseRule & {
    /**
     * Hour of day used for matching
     */
    value?: number;
};

export type BaseRuleWithMinuteOfHourValue = BaseRule & {
    /**
     * Minute of hour used for matching
     */
    value?: number;
};

export type BaseRuleWithBrowserNameValue = BaseRule & {
    /**
     * Browser name used for matching
     */
    value?: 'chrome' | 'microsoft_ie' | 'firefox' | 'microsoft_edge' | 'mozilla' | 'opera' | 'safari';
};

/**
 * Browser name used for matching
 */
export type value2 = 'chrome' | 'microsoft_ie' | 'firefox' | 'microsoft_edge' | 'mozilla' | 'opera' | 'safari';

/**
 * Browser name used for matching
 */
export const value2 = {
    CHROME: 'chrome',
    MICROSOFT_IE: 'microsoft_ie',
    FIREFOX: 'firefox',
    MICROSOFT_EDGE: 'microsoft_edge',
    MOZILLA: 'mozilla',
    OPERA: 'opera',
    SAFARI: 'safari'
} as const;

export type BaseRuleWithOsValue = BaseRule & {
    /**
     * Operating System name used for matching
     */
    value?: 'android' | 'iphone' | 'ipod' | 'ipad' | 'windows' | 'macos' | 'linux';
};

/**
 * Operating System name used for matching
 */
export type value3 = 'android' | 'iphone' | 'ipod' | 'ipad' | 'windows' | 'macos' | 'linux';

/**
 * Operating System name used for matching
 */
export const value3 = {
    ANDROID: 'android',
    IPHONE: 'iphone',
    IPOD: 'ipod',
    IPAD: 'ipad',
    WINDOWS: 'windows',
    MACOS: 'macos',
    LINUX: 'linux'
} as const;

export type BaseRuleWithWeatherConditionValue = BaseRule & {
    /**
     * Weather Condition name used for matching. Full or partial condition.
     *
     * The weather provider used by Convert detects the following conditions:
     * - Blizzard
     * - Blowing snow
     * - Cloudy
     * - Fog
     * - Freezing drizzle
     * - Freezing fog
     * - Heavy freezing drizzle
     * - Heavy rain
     * - Heavy rain at times
     * - Light drizzle
     * - Light freezing rain
     * - Light rain
     * - Mist
     * - Moderate rain
     * - Moderate rain at times
     * - Overcast
     * - Partly cloudy
     *
     */
    value?: string;
};

/**
 * Standardized weather condition strings used for targeting.
 */
export type WeatherConditions = 'Blizzard' | 'Blowing snow' | 'Cloudy' | 'Fog' | 'Freezing drizzle' | 'Freezing fog' | 'Heavy freezing drizzle' | 'Heavy rain' | 'Heavy rain at times' | 'Light drizzle' | 'Light freezing rain' | 'Light rain' | 'Mist' | 'Moderate rain' | 'Moderate rain at times' | 'Overcast' | 'Partly cloudy' | 'Patchy freezing drizzle possible' | 'Patchy light drizzle' | 'Patchy light rain' | 'Patchy rain possible' | 'Patchy sleet possible' | 'Patchy snow possible' | 'Sunny' | 'Thundery outbreaks possible';

/**
 * Standardized weather condition strings used for targeting.
 */
export const WeatherConditions = {
    BLIZZARD: 'Blizzard',
    BLOWING_SNOW: 'Blowing snow',
    CLOUDY: 'Cloudy',
    FOG: 'Fog',
    FREEZING_DRIZZLE: 'Freezing drizzle',
    FREEZING_FOG: 'Freezing fog',
    HEAVY_FREEZING_DRIZZLE: 'Heavy freezing drizzle',
    HEAVY_RAIN: 'Heavy rain',
    HEAVY_RAIN_AT_TIMES: 'Heavy rain at times',
    LIGHT_DRIZZLE: 'Light drizzle',
    LIGHT_FREEZING_RAIN: 'Light freezing rain',
    LIGHT_RAIN: 'Light rain',
    MIST: 'Mist',
    MODERATE_RAIN: 'Moderate rain',
    MODERATE_RAIN_AT_TIMES: 'Moderate rain at times',
    OVERCAST: 'Overcast',
    PARTLY_CLOUDY: 'Partly cloudy',
    PATCHY_FREEZING_DRIZZLE_POSSIBLE: 'Patchy freezing drizzle possible',
    PATCHY_LIGHT_DRIZZLE: 'Patchy light drizzle',
    PATCHY_LIGHT_RAIN: 'Patchy light rain',
    PATCHY_RAIN_POSSIBLE: 'Patchy rain possible',
    PATCHY_SLEET_POSSIBLE: 'Patchy sleet possible',
    PATCHY_SNOW_POSSIBLE: 'Patchy snow possible',
    SUNNY: 'Sunny',
    THUNDERY_OUTBREAKS_POSSIBLE: 'Thundery outbreaks possible'
} as const;

export type BaseMatch = {
    /**
     * If `true`, the logical result of the match is inverted.
     * For example, if `match_type` is 'contains' and `value` is 'apple', `negated: true` means the rule matches if the attribute *does not* contain 'apple'.
     *
     */
    negated?: boolean;
};

export type TextMatchRulesTypes = 'url' | 'url_with_query' | 'query_string' | 'campaign' | 'keyword' | 'medium' | 'source_name' | 'city' | 'region' | 'browser_version' | 'user_agent' | 'page_tag_page_type' | 'page_tag_category_id' | 'page_tag_category_name' | 'page_tag_product_sku' | 'page_tag_product_name' | 'page_tag_customer_id' | 'page_tag_custom_1' | 'page_tag_custom_2' | 'page_tag_custom_3' | 'page_tag_custom_4';

export const TextMatchRulesTypes = {
    URL: 'url',
    URL_WITH_QUERY: 'url_with_query',
    QUERY_STRING: 'query_string',
    CAMPAIGN: 'campaign',
    KEYWORD: 'keyword',
    MEDIUM: 'medium',
    SOURCE_NAME: 'source_name',
    CITY: 'city',
    REGION: 'region',
    BROWSER_VERSION: 'browser_version',
    USER_AGENT: 'user_agent',
    PAGE_TAG_PAGE_TYPE: 'page_tag_page_type',
    PAGE_TAG_CATEGORY_ID: 'page_tag_category_id',
    PAGE_TAG_CATEGORY_NAME: 'page_tag_category_name',
    PAGE_TAG_PRODUCT_SKU: 'page_tag_product_sku',
    PAGE_TAG_PRODUCT_NAME: 'page_tag_product_name',
    PAGE_TAG_CUSTOMER_ID: 'page_tag_customer_id',
    PAGE_TAG_CUSTOM_1: 'page_tag_custom_1',
    PAGE_TAG_CUSTOM_2: 'page_tag_custom_2',
    PAGE_TAG_CUSTOM_3: 'page_tag_custom_3',
    PAGE_TAG_CUSTOM_4: 'page_tag_custom_4'
} as const;

export type NumericMatchRulesTypes = 'avg_time_page' | 'days_since_last_visit' | 'pages_visited_count' | 'visit_duration' | 'visits_count' | 'page_tag_product_price';

export const NumericMatchRulesTypes = {
    AVG_TIME_PAGE: 'avg_time_page',
    DAYS_SINCE_LAST_VISIT: 'days_since_last_visit',
    PAGES_VISITED_COUNT: 'pages_visited_count',
    VISIT_DURATION: 'visit_duration',
    VISITS_COUNT: 'visits_count',
    PAGE_TAG_PRODUCT_PRICE: 'page_tag_product_price'
} as const;

export type BoolMatchRulesTypes = 'bucketed_into_experience' | 'is_desktop' | 'is_mobile' | 'is_tablet';

export const BoolMatchRulesTypes = {
    BUCKETED_INTO_EXPERIENCE: 'bucketed_into_experience',
    IS_DESKTOP: 'is_desktop',
    IS_MOBILE: 'is_mobile',
    IS_TABLET: 'is_tablet'
} as const;

export type GenericTextKeyValueMatchRulesTypes = 'generic_text_key_value';

export const GenericTextKeyValueMatchRulesTypes = {
    GENERIC_TEXT_KEY_VALUE: 'generic_text_key_value'
} as const;

export type GenericNumericKeyValueMatchRulesTypes = 'generic_numeric_key_value';

export const GenericNumericKeyValueMatchRulesTypes = {
    GENERIC_NUMERIC_KEY_VALUE: 'generic_numeric_key_value'
} as const;

export type GenericBoolKeyValueMatchRulesTypes = 'generic_bool_key_value';

export const GenericBoolKeyValueMatchRulesTypes = {
    GENERIC_BOOL_KEY_VALUE: 'generic_bool_key_value'
} as const;

export type JsConditionMatchRulesTypes = 'js_condition';

export const JsConditionMatchRulesTypes = {
    JS_CONDITION: 'js_condition'
} as const;

export type KeyValueMatchRulesTypes = GenericTextKeyValueMatchRulesTypes & GenericNumericKeyValueMatchRulesTypes & GenericBoolKeyValueMatchRulesTypes;

export type CookieMatchRulesTypes = 'cookie';

export const CookieMatchRulesTypes = {
    COOKIE: 'cookie'
} as const;

export type CountryMatchRulesTypes = 'country';

export const CountryMatchRulesTypes = {
    COUNTRY: 'country'
} as const;

export type VisitorTypeMatchRulesTypes = 'visitor_type';

export const VisitorTypeMatchRulesTypes = {
    VISITOR_TYPE: 'visitor_type'
} as const;

export type LanguageMatchRulesTypes = 'language';

export const LanguageMatchRulesTypes = {
    LANGUAGE: 'language'
} as const;

export type GoalTriggeredMatchRulesTypes = 'goal_triggered';

export const GoalTriggeredMatchRulesTypes = {
    GOAL_TRIGGERED: 'goal_triggered'
} as const;

export type SegmentBucketedMatchRulesTypes = 'bucketed_into_segment';

export const SegmentBucketedMatchRulesTypes = {
    BUCKETED_INTO_SEGMENT: 'bucketed_into_segment'
} as const;

export type DayOfWeekMatchRulesTypes = 'local_time_day_of_week' | 'project_time_day_of_week';

export const DayOfWeekMatchRulesTypes = {
    LOCAL_TIME_DAY_OF_WEEK: 'local_time_day_of_week',
    PROJECT_TIME_DAY_OF_WEEK: 'project_time_day_of_week'
} as const;

export type HourOfDayMatchRulesTypes = 'local_time_hour_of_day' | 'project_time_hour_of_day';

export const HourOfDayMatchRulesTypes = {
    LOCAL_TIME_HOUR_OF_DAY: 'local_time_hour_of_day',
    PROJECT_TIME_HOUR_OF_DAY: 'project_time_hour_of_day'
} as const;

export type MinuteOfHourMatchRulesTypes = 'local_time_minute_of_hour' | 'project_time_minute_of_hour';

export const MinuteOfHourMatchRulesTypes = {
    LOCAL_TIME_MINUTE_OF_HOUR: 'local_time_minute_of_hour',
    PROJECT_TIME_MINUTE_OF_HOUR: 'project_time_minute_of_hour'
} as const;

export type BrowserNameMatchRulesTypes = 'browser_name';

export const BrowserNameMatchRulesTypes = {
    BROWSER_NAME: 'browser_name'
} as const;

export type OsMatchRulesTypes = 'os';

export const OsMatchRulesTypes = {
    OS: 'os'
} as const;

export type WeatherConditionMatchRulesTypes = 'weather_condition';

export const WeatherConditionMatchRulesTypes = {
    WEATHER_CONDITION: 'weather_condition'
} as const;

export type RulesTypes = TextMatchRulesTypes & NumericMatchRulesTypes & BoolMatchRulesTypes & KeyValueMatchRulesTypes & CookieMatchRulesTypes & CountryMatchRulesTypes & VisitorTypeMatchRulesTypes & LanguageMatchRulesTypes & GoalTriggeredMatchRulesTypes & SegmentBucketedMatchRulesTypes & DayOfWeekMatchRulesTypes & HourOfDayMatchRulesTypes & MinuteOfHourMatchRulesTypes & BrowserNameMatchRulesTypes & OsMatchRulesTypes & WeatherConditionMatchRulesTypes;

export type GenericTextMatchRule = BaseRuleWithStringValue & {
    rule_type: TextMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: TextMatchingOptions;
});
};

export type GenericNumericMatchRule = BaseRuleWithNumericValue & {
    rule_type: NumericMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: NumericMatchingOptions;
});
};

export type GenericBoolMatchRule = BaseRuleWithBooleanValue & {
    rule_type: BoolMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type GenericSetMatchRule = BaseRuleWithStringValue & {
    rule_type: string;
    matching?: (BaseMatch & {
    match_type?: SetMatchingOptions;
});
};

export type GenericKey = {
    /**
     * The name of the key whose value will be retrieved and compared against the rule's `value`.
     */
    key?: string;
};

export type GenericTextKeyValueMatchRule = BaseRuleWithStringValue & {
    rule_type: GenericTextKeyValueMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: TextMatchingOptions;
});
} & GenericKey;

export type GenericNumericKeyValueMatchRule = BaseRuleWithNumericValue & {
    rule_type: GenericNumericKeyValueMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: NumericMatchingOptions;
});
} & GenericKey;

export type GenericBoolKeyValueMatchRule = BaseRuleWithBooleanValue & {
    rule_type: GenericBoolKeyValueMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
} & GenericKey;

export type CookieMatchRule = BaseRuleWithStringValue & {
    rule_type: CookieMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: TextMatchingOptions;
});
    /**
     * The name of the cookie which value is compared to the given rule value
     */
    key?: string;
};

export type CountryMatchRule = BaseRuleWithCountryCodeValue & {
    rule_type: CountryMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type JsConditionMatchRule = BaseRuleWithJsCodeValue & {
    rule_type: JsConditionMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type VisitorTypeMatchRule = BaseRuleWithVisitorTypeValue & {
    rule_type: VisitorTypeMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type LanguageMatchRule = BaseRuleWithLanguageCodeValue & {
    rule_type: LanguageMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type GoalTriggeredMatchRule = BaseRuleWithGoalTriggeredValue & {
    rule_type: GoalTriggeredMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type SegmentBucketedMatchRule = BaseRuleWithSegmentBucketedValue & {
    rule_type: SegmentBucketedMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type ExperienceBucketedMatchRule = BaseRuleWithExperienceBucketedValue & {
    rule_type: string;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type DayOfWeekMatchRule = BaseRuleWithDayOfWeekValue & {
    rule_type: DayOfWeekMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: NumericMatchingOptions;
});
};

export type HourOfDayMatchRule = BaseRuleWithHourOfDayValue & {
    rule_type: HourOfDayMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: NumericMatchingOptions;
});
};

export type MinuteOfHourMatchRule = BaseRuleWithMinuteOfHourValue & {
    rule_type: MinuteOfHourMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: NumericMatchingOptions;
});
};

export type BrowserNameMatchRule = BaseRuleWithBrowserNameValue & {
    rule_type: BrowserNameMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type OsMatchRule = BaseRuleWithOsValue & {
    rule_type: OsMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: ChoiceMatchingOptions;
});
};

export type WeatherConditionMatchRule = BaseRuleWithWeatherConditionValue & {
    rule_type: WeatherConditionMatchRulesTypes;
    matching?: (BaseMatch & {
    match_type?: TextMatchingOptions;
});
};

export type RuleElementNoUrl = GenericTextMatchRule | GenericNumericMatchRule | GenericBoolMatchRule | CookieMatchRule | GenericTextKeyValueMatchRule | GenericNumericKeyValueMatchRule | GenericBoolKeyValueMatchRule | CountryMatchRule | LanguageMatchRule | GoalTriggeredMatchRule | SegmentBucketedMatchRule | DayOfWeekMatchRule | HourOfDayMatchRule | MinuteOfHourMatchRule | BrowserNameMatchRule | OsMatchRule | WeatherConditionMatchRule | VisitorTypeMatchRule | JsConditionMatchRule;

export type RuleElement = GenericTextMatchRule | GenericNumericMatchRule | GenericBoolMatchRule | GenericTextKeyValueMatchRule | GenericNumericKeyValueMatchRule | GenericBoolKeyValueMatchRule | CookieMatchRule | CountryMatchRule | LanguageMatchRule | GoalTriggeredMatchRule | SegmentBucketedMatchRule | DayOfWeekMatchRule | HourOfDayMatchRule | MinuteOfHourMatchRule | BrowserNameMatchRule | OsMatchRule | WeatherConditionMatchRule | VisitorTypeMatchRule | JsConditionMatchRule;

export type TextMatchingOptions = 'matches' | 'regexMatches' | 'contains' | 'endsWith' | 'startsWith';

export const TextMatchingOptions = {
    MATCHES: 'matches',
    REGEX_MATCHES: 'regexMatches',
    CONTAINS: 'contains',
    ENDS_WITH: 'endsWith',
    STARTS_WITH: 'startsWith'
} as const;

export type NumericMatchingOptions = 'equalsNumber' | 'less' | 'lessEqual';

export const NumericMatchingOptions = {
    EQUALS_NUMBER: 'equalsNumber',
    LESS: 'less',
    LESS_EQUAL: 'lessEqual'
} as const;

export type ChoiceMatchingOptions = 'equals';

export const ChoiceMatchingOptions = {
    EQUALS: 'equals'
} as const;

export type ChoiceContainsOptions = 'contains';

export const ChoiceContainsOptions = {
    CONTAINS: 'contains'
} as const;

export type SetMatchingOptions = 'isIn';

export const SetMatchingOptions = {
    IS_IN: 'isIn'
} as const;

/**
 * Defines the logical structure for combining multiple rule conditions. It uses a nested OR -> AND -> OR_WHEN structure.
 * - The top-level `OR` array means if *any* of its contained AND blocks evaluate to true, the entire rule set is true.
 * - Each object within the `OR` array has an `AND` array. For this AND block to be true, *all* of its contained OR_WHEN blocks must evaluate to true.
 * - Each object within the `AND` array has an `OR_WHEN` array. For this OR_WHEN block to be true, *any* of its individual `RuleElement` conditions must evaluate to true.
 * This structure allows for complex logical expressions like `(CondA AND CondB) OR (CondC AND CondD)`.
 *
 */
export type RuleObject = {
    /**
     * An array of AND-blocks. The overall rule matches if any of these AND-blocks match.
     */
    OR?: Array<{
        /**
         * An array of OR_WHEN-blocks. This AND-block matches if all its OR_WHEN-blocks match.
         */
        AND?: Array<{
            /**
             * An array of individual rule elements. This OR_WHEN-block matches if any of its rule elements match.
             */
            OR_WHEN?: Array<RuleElement>;
        }>;
    }>;
} | null;

/**
 * Similar to `RuleObject`, but the individual `RuleElementNoUrl` conditions within `OR_WHEN` arrays cannot include URL-based matching types.
 * Used for 'permanent' or 'transient' audiences where URL context is not persistently evaluated or relevant for the audience type.
 *
 */
export type RuleObjectNoUrl = {
    /**
     * An array of AND-blocks.
     */
    OR?: Array<{
        /**
         * An array of OR_WHEN-blocks.
         */
        AND?: Array<{
            /**
             * An array of individual rule elements that do not involve URL matching.
             */
            OR_WHEN?: Array<RuleElementNoUrl>;
        }>;
    }>;
} | null;

export type Base64Image = {
    /**
     * The base64 encoded string representation of the image's binary data.
     */
    data?: string;
};

export type ErrorData = {
    code?: number;
    message?: string;
    fields?: string;
};

export type SuccessData = {
    code?: number;
    message?: string;
};

export type ImportProjectDataSuccess = SuccessData & {
    /**
     * List of imported objects
     */
    imported?: {
        /**
         * List of created experiences. Empty if nothing imported
         */
        experiences?: Array<(number)>;
        /**
         * List of created audiences. Empty if nothing imported
         */
        audiences?: Array<(number)>;
        /**
         * List of created locations. Empty if nothing imported
         */
        locations?: Array<(number)>;
        /**
         * List of created goals. Empty if nothing imported
         */
        goals?: Array<(number)>;
        /**
         * List of created hypothesis. Empty if nothing imported
         */
        hypothesis?: Array<(number)>;
    };
};

export type BulkSuccessData = SuccessData & {
    code?: number;
    /**
     * List of unprocessed entities. Would be empty, if all passed entities processed
     */
    errors?: Array<BulkEntityError>;
};

export type BulkEntityError = {
    /**
     * The unique identifier of the entity that could not be processed.
     */
    id?: number;
    /**
     * A message explaining the reason for the failure for this specific entity.
     */
    message?: string;
};

/**
 * Offset in seconds, from UTC time, for the give timezone
 */
export type UTC_Offset = number;

export type GA_SettingsBase = {
    /**
     * If true, integration with Google Analytics is enabled for this project or experience, allowing experiment data to be sent to GA.
     */
    enabled?: boolean;
};

export type IntegrationGA3 = {
    type?: 'ga3';
    /**
     * The Universal Analytics Property ID (e.g., "UA-XXXXXXXX-Y") to which Convert experiment data will be sent.
     */
    property_UA?: (string) | null;
};

export type type = 'ga3';

export const type = {
    GA3: 'ga3'
} as const;

export type IntegrationGA4Base = {
    type?: 'ga4';
    /**
     * The GA4 Measurement ID (e.g., "G-XXXXXXXXXX") for the data stream where Convert experiment data will be sent.
     */
    measurementId?: string;
};

export type type2 = 'ga4';

export const type2 = {
    GA4: 'ga4'
} as const;

export type IntegrationGA4 = IntegrationGA4Base & {
    /**
     * ID of the ga4 property where data will be sent. Used internally for API calls to GoogleAnalytics
     */
    propertyId?: string;
};

/**
 * Defines how multiple conditions within a list (e.g., multiple audiences or locations linked to an experience) are logically combined:
 * - `any`: The overall condition is met if *at least one* item in the list matches (logical OR).
 * - `all`: The overall condition is met only if *all* items in the list match (logical AND).
 * Default is typically 'any' (OR).
 *
 */
export type GenericListMatchingOptions = 'any' | 'all';

/**
 * Defines how multiple conditions within a list (e.g., multiple audiences or locations linked to an experience) are logically combined:
 * - `any`: The overall condition is met if *at least one* item in the list matches (logical OR).
 * - `all`: The overall condition is met only if *all* items in the list match (logical AND).
 * Default is typically 'any' (OR).
 *
 */
export const GenericListMatchingOptions = {
    ANY: 'any',
    ALL: 'all'
} as const;

export type VisitorInsightsBase = {
    /**
     * If true, Convert Signals™ is enabled for the project, allowing the system to capture sessions exhibiting user frustration or usability issues.
     *
     */
    enabled?: boolean;
};

/**
 * The method used for detecting and handling order outliers in revenue or product count tracking:
 * - `none`: No outlier detection is applied.
 * - `min_max`: Orders with values below a specified minimum or above a specified maximum are capped at those boundaries.
 * - `percentile`: Orders falling below a lower percentile or above an upper percentile are capped at the values corresponding to those percentiles.
 *
 */
export type NumericOutlierTypes = 'none' | 'min_max' | 'percentile';

/**
 * The method used for detecting and handling order outliers in revenue or product count tracking:
 * - `none`: No outlier detection is applied.
 * - `min_max`: Orders with values below a specified minimum or above a specified maximum are capped at those boundaries.
 * - `percentile`: Orders falling below a lower percentile or above an upper percentile are capped at the values corresponding to those percentiles.
 *
 */
export const NumericOutlierTypes = {
    NONE: 'none',
    MIN_MAX: 'min_max',
    PERCENTILE: 'percentile'
} as const;

export type NumericOutlierBase = {
    detection_type: NumericOutlierTypes;
};

export type NumericOutlierNone = NumericOutlierBase & {
    detection_type?: 'none';
};

export type detection_type = 'none';

export const detection_type = {
    NONE: 'none'
} as const;

export type NumericOutlierMinMax = NumericOutlierBase & {
    detection_type?: 'min_max';
    /**
     * Minimum value for the outlier detection, under which, the value is considered an outlier
     */
    min?: number;
    /**
     * Maximum value for the outlier detection, over which, the value is considered an outlier
     */
    max?: number;
};

export type detection_type2 = 'min_max';

export const detection_type2 = {
    MIN_MAX: 'min_max'
} as const;

export type NumericOutlierPercentile = NumericOutlierBase & {
    detection_type?: 'percentile';
    min?: (unknown & Percentiles);
    max?: (unknown & Percentiles);
};

export type detection_type3 = 'percentile';

export const detection_type3 = {
    PERCENTILE: 'percentile'
} as const;

export type NumericOutlier = NumericOutlierNone | NumericOutlierMinMax | NumericOutlierPercentile;

/**
 * Standard percentile values used for outlier detection thresholds.
 * For example, a `min` of 5 and `max` of 95 means orders in the bottom 5% and top 5% of values are considered outliers and capped.
 *
 */
export type Percentiles = 1 | 5 | 10 | 25 | 50 | 75 | 90 | 95 | 99;

/**
 * Standard percentile values used for outlier detection thresholds.
 * For example, a `min` of 5 and `max` of 95 means orders in the bottom 5% and top 5% of values are considered outliers and capped.
 *
 */
export const Percentiles = {
    '_1': 1,
    '_5': 5,
    '_10': 10,
    '_25': 25,
    '_50': 50,
    '_75': 75,
    '_90': 90,
    '_95': 95,
    '_99': 99
} as const;

export type TimeRange = {
    /**
     * Unix timestamp (seconds since epoch, UTC) marking the beginning of the time range. If null, implies from the beginning of data.
     */
    start_time?: (number) | null;
    /**
     * Unix timestamp (seconds since epoch, UTC) marking the end of the time range. If null, implies up to the current time.
     */
    end_time?: (number) | null;
    utc_offset?: UTC_Offset;
};

/**
 * File Object
 */
export type UploadedFileData = {
    /**
     * Storage key of the uploaded file.
     */
    key?: string;
    /**
     * Original name of the uploaded file.
     */
    name?: string;
    /**
     * Endpoint to access the file resource associated with the project.
     */
    readonly url?: string;
};

/**
 * A server-generated hash that represents the object's state at the time of retrieval. When included in an update request, the operation will only succeed if the object hasn't been modified since this key was obtained. If another update has occurred in the meantime, the request will fail with a conflict error, requiring you to fetch the latest version and retry your update with the new concurrency_key. This implements optimistic concurrency control to prevent lost updates in concurrent scenarios.
 */
export type ConcurrencyKey = (string) | null;

/**
 * Response containing project's config data needed in order to serve experiences
 */
export type ConfigResponseData = {
    /**
     * Account ID under which the project exists
     */
    account_id?: string;
    project?: ConfigProject;
    /**
     * List of goals to be tracked in the project
     */
    goals?: Array<ConfigGoal>;
    /**
     * List of locations that are used inside this project
     */
    locations?: Array<ConfigLocation>;
    /**
     * List of audiences that are used inside this project
     */
    audiences?: Array<ConfigAudience>;
    /**
     * List of custom that are devined inside this project
     */
    segments?: Array<ConfigSegment>;
    /**
     * List of active experiences inside this project
     */
    experiences?: Array<ConfigExperience>;
    /**
     * List of archived experiences inside this project, which were archived within the last 8 months
     */
    archived_experiences?: Array<(string)>;
    /**
     * List of features inside this project. Presented only for fullstack projects
     */
    features?: Array<ConfigFeature>;
    /**
     * Flag indicating if the returned config is in debug mode
     */
    is_debug?: boolean;
};

export type ConfigMinimalResponseData = {
    /**
     * Account ID
     */
    account_id?: string;
    /**
     * Project ID
     */
    project_id?: string;
} & ConfigProjectMinimalSettings;

/**
 * Limited data containing optional properties required for decision-making when assembling and
 * tracking various bundles (e.g., tracking scripts).
 *
 */
export type ConfigOptionalResponseData = {
    /**
     * Account ID
     */
    account_id?: string;
    /**
     * Project ID
     */
    project_id?: string;
    visitor_insights?: VisitorInsightsData;
};

/**
 * The fundamental structure representing a single modification applied within an experience's variation. The specific content and behavior of the change are determined by its `type` and detailed in the `data` object.
 */
export type ExperienceChangeBase = {
    type?: 'richStructure' | 'customCode' | 'defaultCode' | 'defaultCodeMultipage' | 'defaultRedirect' | 'fullStackFeature';
    /**
     * A flexible object containing the specific details and content for this change, structured according to the change `type`.
     * For example, for `customCode`, it would contain `js` and `css` strings. For `defaultRedirect`, it would contain `original_pattern` and `variation_pattern`.
     * This field is included by default when fetching a single `ExperienceChange` but might be omitted in list views unless specified in an `include` parameter.
     *
     */
    data?: {
        [key: string]: unknown;
    };
};

export type type3 = 'richStructure' | 'customCode' | 'defaultCode' | 'defaultCodeMultipage' | 'defaultRedirect' | 'fullStackFeature';

export const type3 = {
    RICH_STRUCTURE: 'richStructure',
    CUSTOM_CODE: 'customCode',
    DEFAULT_CODE: 'defaultCode',
    DEFAULT_CODE_MULTIPAGE: 'defaultCodeMultipage',
    DEFAULT_REDIRECT: 'defaultRedirect',
    FULL_STACK_FEATURE: 'fullStackFeature'
} as const;

/**
 * Represents the unique identifier of an existing change within an experience variation. Used when updating or referencing a specific change.
 */
export type ExperienceChangeId = {
    /**
     * The unique numerical identifier for this specific change.
     */
    id: number;
};

/**
 * Represents the unique identifier of a change, typically when returned by the API after creation or in a list.
 */
export type ExperienceChangeIdReadOnly = {
    /**
     * The unique numerical identifier for this specific change.
     */
    readonly id?: number;
};

/**
 * Object that represents one change done inside an experience
 */
export type ExperienceChangeServing = ExperienceChangeDefaultCodeDataServing | ExperienceChangeDefaultCodeMultipageDataServing | ExperienceChangeDefaultRedirectDataServing | ExperienceChangeCustomCodeDataServing | ExperienceChangeRichStructureDataServing | ExperienceChangeFullStackFeatureServing;

/**
 * Represents a single, specific modification applied as part of an experience's variation. The exact structure and content depend on the `type` of change.
 */
export type ExperienceChange = ExperienceChangeDefaultCodeData | ExperienceChangeDefaultCodeMultipageData | ExperienceChangeDefaultRedirectData | ExperienceChangeCustomCodeData | ExperienceChangeRichStructureData | ExperienceChangeFullStackFeature;

/**
 * Data structure for adding a new change to an experience variation. The `id` field is omitted as it will be assigned upon creation.
 */
export type ExperienceChangeAdd = ExperienceChangeDefaultCodeDataAdd | ExperienceChangeDefaultCodeMultipageDataAdd | ExperienceChangeDefaultRedirectDataAdd | ExperienceChangeCustomCodeDataAdd | ExperienceChangeRichStructureDataAdd | ExperienceChangeFullStackFeatureAdd;

/**
 * Data structure for updating an existing change within an experience variation. Requires the `id` of the change to be modified.
 */
export type ExperienceChangeUpdate = ExperienceChangeDefaultCodeDataUpdate | ExperienceChangeDefaultCodeMultipageDataUpdate | ExperienceChangeDefaultRedirectDataUpdate | ExperienceChangeRichStructureDataUpdate | ExperienceChangeCustomCodeDataUpdate | ExperienceChangeFullStackFeatureUpdate;

/**
 * Data structure for defining a change when updating a collection of changes (e.g., within a variation update), where the `id` might be part of a parent object or implied.
 */
export type ExperienceChangeUpdateNoId = ExperienceChangeDefaultCodeDataUpdateNoId | ExperienceChangeDefaultCodeMultipageDataUpdateNoId | ExperienceChangeDefaultRedirectDataUpdateNoId | ExperienceChangeRichStructureDataUpdateNoId | ExperienceChangeCustomCodeDataUpdateNoId | ExperienceChangeFullStackFeatureUpdateNoId;

/**
 * Defines a standard code-based change, typically generated by the Visual Editor for modifications like text replacement, style changes, or element removal. It can include CSS, Convert's internal JS representation, and custom JS.
 */
export type ExperienceChangeDefaultCodeDataBase = ExperienceChangeBase & {
    type?: 'defaultCode';
    /**
     * Describes structure for "defaultCode" type of experience change
     */
    data?: {
        /**
         * CSS code to be applied by this change
         */
        css?: (string) | null;
        /**
         * Javascript code generated by the visual editor or written in the same structure, to be applied by this experience change
         */
        js?: (string) | null;
        /**
         * Custom javascript code to be applied by this change
         */
        custom_js?: (string) | null;
    };
};

export type type4 = 'defaultCode';

export const type4 = {
    DEFAULT_CODE: 'defaultCode'
} as const;

/**
 * Represents a 'defaultCode' type change, including its system-assigned ID.
 */
export type ExperienceChangeDefaultCodeData = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeDataBase & {
    concurrency_key?: ConcurrencyKey;
};

/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeDefaultCodeDataServing = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeDataBase;

/**
 * Data for creating a new 'defaultCode' type change.
 */
export type ExperienceChangeDefaultCodeDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeDataBase & {
    data: unknown;
};

/**
 * Data for updating a 'defaultCode' type change when its ID is managed externally.
 */
export type ExperienceChangeDefaultCodeDataUpdateNoId = ExperienceChangeDefaultCodeDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Data for updating an existing 'defaultCode' type change, identified by its `id`.
 */
export type ExperienceChangeDefaultCodeDataUpdate = ExperienceChangeId & ExperienceChangeDefaultCodeDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Defines a URL redirect, typically used in Split URL experiments. It specifies how to match an original URL and construct the URL for the variation page.
 */
export type ExperienceChangeDefaultRedirectDataBase = ExperienceChangeBase & {
    type?: 'defaultRedirect';
    /**
     * Describes structure for "defaultRedirect" type of experience change
     */
    data?: {
        /**
         * Defines whether the URL matching is case sensitive or not
         */
        case_sensitive?: boolean;
        /**
         * Pattern for matching the Original URL in order to construct the redirect URL
         */
        original_pattern?: string;
        /**
         * String used to construct the variation redirect URL. This string can contain matches from original_url or it can be a standard URL
         */
        variation_pattern?: string;
    };
};

export type type5 = 'defaultRedirect';

export const type5 = {
    DEFAULT_REDIRECT: 'defaultRedirect'
} as const;

/**
 * Represents a 'defaultRedirect' type change, including its system-assigned ID.
 */
export type ExperienceChangeDefaultRedirectData = ExperienceChangeIdReadOnly & ExperienceChangeDefaultRedirectDataBase & {
    concurrency_key?: ConcurrencyKey;
};

/**
 * Describes structure for "defaultRedirect" type of experience change
 */
export type ExperienceChangeDefaultRedirectDataServing = ExperienceChangeIdReadOnly & ExperienceChangeDefaultRedirectDataBase;

/**
 * Data for creating a new 'defaultRedirect' type change.
 */
export type ExperienceChangeDefaultRedirectDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeDefaultRedirectDataBase & {
    data: unknown;
};

/**
 * Data for updating a 'defaultRedirect' type change when its ID is managed externally.
 */
export type ExperienceChangeDefaultRedirectDataUpdateNoId = ExperienceChangeDefaultRedirectDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Data for updating an existing 'defaultRedirect' type change, identified by its `id`.
 */
export type ExperienceChangeDefaultRedirectDataUpdate = ExperienceChangeId & ExperienceChangeDefaultRedirectDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Defines a standard code-based change that applies to a specific page within a Multi-page Funnel experiment. This allows different code (CSS, JS) to be applied to different steps of the funnel for the same variation.
 */
export type ExperienceChangeDefaultCodeMultipageDataBase = ExperienceChangeBase & {
    type?: 'defaultCodeMultipage';
    /**
     * Describes structure for "defaultCodeMultipage" type of experience change
     */
    data?: {
        /**
         * CSS code to be applied by this change
         */
        css?: (string) | null;
        /**
         * Javascript code generated by the visual editor or written in the same structure, to be applied by this experience change
         */
        js?: (string) | null;
        /**
         * Custom javascript code to be applied by this change
         */
        custom_js?: (string) | null;
        /**
         * The **id** of the page connected to this change.
         */
        page_id?: string;
    };
};

export type type6 = 'defaultCodeMultipage';

export const type6 = {
    DEFAULT_CODE_MULTIPAGE: 'defaultCodeMultipage'
} as const;

/**
 * Represents a 'defaultCodeMultipage' type change, including its system-assigned ID.
 */
export type ExperienceChangeDefaultCodeMultipageData = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeMultipageDataBase & {
    concurrency_key?: ConcurrencyKey;
};

/**
 * Describes structure for "defaultCodeMultipage" type of experience change
 */
export type ExperienceChangeDefaultCodeMultipageDataServing = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeMultipageDataBase;

/**
 * Data for creating a new 'defaultCodeMultipage' type change.
 */
export type ExperienceChangeDefaultCodeMultipageDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeMultipageDataBase & {
    data: unknown;
};

/**
 * Data for updating a 'defaultCodeMultipage' type change when its ID is managed externally.
 */
export type ExperienceChangeDefaultCodeMultipageDataUpdateNoId = ExperienceChangeDefaultCodeMultipageDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Data for updating an existing 'defaultCodeMultipage' type change, identified by its `id`.
 */
export type ExperienceChangeDefaultCodeMultipageDataUpdate = ExperienceChangeId & ExperienceChangeDefaultCodeMultipageDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Defines a complex change, often involving multiple DOM manipulations or structured data, typically generated by advanced Visual Editor interactions or specific integrations. (Primarily for internal or advanced programmatic use).
 */
export type ExperienceChangeRichStructureDataBase = ExperienceChangeBase & {
    type?: 'richStructure';
    /**
     * Describes structure for "defaultCode" type of experience change
     */
    data?: {
        /**
         * Javascript code generated by the visual editor or written in the same structure, to be applied by this experience change
         */
        js?: (string) | null;
        /**
         * CSS selector of the element to which the change refers to, if this is a change concerning one DOM element
         */
        selector?: string;
        /**
         * The **id** of the page connected to this change, in case this is a **multi-page** experiment
         */
        page_id?: string;
        /**
         * Various key - value data
         */
        [key: string]: (string) | undefined;
    };
};

export type type7 = 'richStructure';

export const type7 = {
    RICH_STRUCTURE: 'richStructure'
} as const;

/**
 * Represents a 'richStructure' type change, including its system-assigned ID.
 */
export type ExperienceChangeRichStructureData = ExperienceChangeIdReadOnly & ExperienceChangeRichStructureDataBase & {
    concurrency_key?: ConcurrencyKey;
};

/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeRichStructureDataServing = ExperienceChangeIdReadOnly & ExperienceChangeRichStructureDataBase;

/**
 * Data for creating a new 'richStructure' type change.
 */
export type ExperienceChangeRichStructureDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeRichStructureDataBase & {
    data: unknown;
};

/**
 * Data for updating a 'richStructure' type change when its ID is managed externally.
 */
export type ExperienceChangeRichStructureDataUpdateNoId = ExperienceChangeRichStructureDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Data for updating an existing 'richStructure' type change, identified by its `id`.
 */
export type ExperienceChangeRichStructureDataUpdate = ExperienceChangeId & ExperienceChangeRichStructureDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Defines a change applied purely through custom-written CSS and/or JavaScript code, bypassing the Visual Editor's generated code. This offers maximum flexibility for developers.
 */
export type ExperienceChangeCustomCodeDataBase = ExperienceChangeBase & {
    type?: 'customCode';
    /**
     * Describes structure for "defaultCode" type of experience change
     */
    data?: {
        /**
         * CSS code to be applied by this change
         */
        css?: (string) | null;
        /**
         * Custom javascript code to be applied by this change
         */
        js?: (string) | null;
        /**
         * The **id** of the page connected to this change, in case this is a **multi-page** experiment
         */
        page_id?: string;
    };
};

export type type8 = 'customCode';

export const type8 = {
    CUSTOM_CODE: 'customCode'
} as const;

/**
 * Represents a 'customCode' type change, including its system-assigned ID.
 */
export type ExperienceChangeCustomCodeData = ExperienceChangeIdReadOnly & ExperienceChangeCustomCodeDataBase & {
    concurrency_key?: ConcurrencyKey;
};

/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeCustomCodeDataServing = ExperienceChangeIdReadOnly & ExperienceChangeCustomCodeDataBase;

/**
 * Data for creating a new 'customCode' type change.
 */
export type ExperienceChangeCustomCodeDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeCustomCodeDataBase & {
    data: unknown;
};

/**
 * Data for updating a 'customCode' type change when its ID is managed externally.
 */
export type ExperienceChangeCustomCodeDataUpdateNoId = ExperienceChangeCustomCodeDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Data for updating an existing 'customCode' type change, identified by its `id`.
 */
export type ExperienceChangeCustomCodeDataUpdate = ExperienceChangeId & ExperienceChangeCustomCodeDataBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Defines a change for a Full Stack experiment that involves enabling or configuring a specific 'Feature' and its variables for this variation.
 */
export type ExperienceChangeFullStackFeatureBase = ExperienceChangeBase & {
    type?: 'fullStackFeature';
    /**
     * Describes structure for "fullStackFeature" type of experience change
     */
    data?: {
        /**
         * The **id** of the feature connected to this change
         */
        feature_id?: number;
        /**
         * A key-value object defined by user which describes the variables values. Where the key is variable name defined in connected feature and value is a variable's value with corresponding type
         */
        variables_data?: {
            [key: string]: unknown;
        };
    };
};

export type type9 = 'fullStackFeature';

export const type9 = {
    FULL_STACK_FEATURE: 'fullStackFeature'
} as const;

/**
 * Represents a 'fullStackFeature' type change, including its system-assigned ID.
 */
export type ExperienceChangeFullStackFeature = ExperienceChangeIdReadOnly & ExperienceChangeFullStackFeatureBase & {
    concurrency_key?: ConcurrencyKey;
};

/**
 * Describes structure for "fullStackFeature" type of experience change
 */
export type ExperienceChangeFullStackFeatureServing = ExperienceChangeIdReadOnly & ExperienceChangeFullStackFeatureBase;

/**
 * Data for creating a new 'fullStackFeature' type change.
 */
export type ExperienceChangeFullStackFeatureAdd = ExperienceChangeIdReadOnly & ExperienceChangeFullStackFeatureBase & {
    data: unknown;
};

/**
 * Data for updating an existing 'fullStackFeature' type change, identified by its `id`.
 */
export type ExperienceChangeFullStackFeatureUpdate = ExperienceChangeId & ExperienceChangeFullStackFeatureBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

/**
 * Data for updating a 'fullStackFeature' type change when its ID is managed externally.
 */
export type ExperienceChangeFullStackFeatureUpdateNoId = ExperienceChangeFullStackFeatureBase & {
    concurrency_key?: ConcurrencyKey;
} & unknown;

export type UpdateExperienceChangeRequestData = ExperienceChangeAdd;

/**
 * Identifies the third-party analytics, heatmap, or data platform with which Convert Experiences is integrated for this specific experience.
 * This allows experiment data (like experience ID and variation ID/name) to be sent to the selected provider.
 * Knowledge Base has many articles on integrations, e.g., "Integrate Convert Experiences with Google Analytics", "Hotjar Integration".
 *
 */
export type IntegrationProvider = 'baidu' | 'clicktale' | 'clicky' | 'cnzz' | 'crazyegg' | 'econda' | 'eulerian' | 'google_analytics' | 'gosquared' | 'heapanalytics' | 'hotjar' | 'mixpanel' | 'mouseflow' | 'piwik' | 'segmentio' | 'sitecatalyst' | 'woopra' | 'ysance';

/**
 * Identifies the third-party analytics, heatmap, or data platform with which Convert Experiences is integrated for this specific experience.
 * This allows experiment data (like experience ID and variation ID/name) to be sent to the selected provider.
 * Knowledge Base has many articles on integrations, e.g., "Integrate Convert Experiences with Google Analytics", "Hotjar Integration".
 *
 */
export const IntegrationProvider = {
    BAIDU: 'baidu',
    CLICKTALE: 'clicktale',
    CLICKY: 'clicky',
    CNZZ: 'cnzz',
    CRAZYEGG: 'crazyegg',
    ECONDA: 'econda',
    EULERIAN: 'eulerian',
    GOOGLE_ANALYTICS: 'google_analytics',
    GOSQUARED: 'gosquared',
    HEAPANALYTICS: 'heapanalytics',
    HOTJAR: 'hotjar',
    MIXPANEL: 'mixpanel',
    MOUSEFLOW: 'mouseflow',
    PIWIK: 'piwik',
    SEGMENTIO: 'segmentio',
    SITECATALYST: 'sitecatalyst',
    WOOPRA: 'woopra',
    YSANCE: 'ysance'
} as const;

export type ExperienceIntegrationBase = {
    provider: IntegrationProvider;
    /**
     * If `true`, this integration is active for the experience, and Convert will attempt to send experiment data to the specified provider.
     * If `false` or omitted when updating, the integration is disabled.
     *
     */
    enabled?: (boolean) | null;
};

export type ExperienceIntegrationBaidu = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};

export type ExperienceIntegrationClicktale = ExperienceIntegrationBase;

export type ExperienceIntegrationClicky = ExperienceIntegrationBase;

export type ExperienceIntegrationCnzz = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};

/**
 * Configuration for integrating with Crazy Egg. Convert sends experiment and variation data to allow segmentation of Crazy Egg heatmaps and recordings by variation.
 * Project-level API key and secret for Crazy Egg might be required for some functionalities (not specified here, but in KB for other tools).
 * KB: "Integrate Convert Experiences with Crazy Egg".
 *
 */
export type ExperienceIntegrationCrazyegg = ExperienceIntegrationBase;

export type ExperienceIntegrationEconda = ExperienceIntegrationBase;

export type ExperienceIntegrationEulerian = ExperienceIntegrationBase;

export type ExperienceIntegrationGA3 = GA_SettingsBase & ExperienceIntegrationBase & IntegrationGA3 & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension?: string;
};

export type ExperienceIntegrationGA4Base = GA_SettingsBase & ExperienceIntegrationBase & IntegrationGA4Base;

export type ExperienceIntegrationGA4 = ExperienceIntegrationGA4Base & IntegrationGA4 & {
    /**
     * List of GA audiences created for each of this experience's variations
     */
    audiences?: {
        [key: string]: (string);
    };
};

export type ExperienceIntegrationGoogleAnalytics = ExperienceIntegrationGA3 | ExperienceIntegrationGA4;

export type ExperienceIntegrationGosquared = ExperienceIntegrationBase;

export type ExperienceIntegrationHeapanalytics = ExperienceIntegrationBase;

export type ExperienceIntegrationHotjar = ExperienceIntegrationBase;

export type ExperienceIntegrationMixpanel = ExperienceIntegrationBase;

export type ExperienceIntegrationMouseflow = ExperienceIntegrationBase;

export type ExperienceIntegrationPiwik = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};

export type ExperienceIntegrationSegmentio = ExperienceIntegrationBase;

export type ExperienceIntegrationSitecatalyst = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    evar: string;
};

export type ExperienceIntegrationWoopra = ExperienceIntegrationBase;

export type ExperienceIntegrationYsance = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};

export type ConfigExperience = {
    /**
     * Experience ID
     */
    id?: string;
    /**
     * Experience Name
     */
    name?: string;
    /**
     * Experience readable key that uniquely identifies this experience
     */
    key?: string;
    /**
     * List of locations IDs on which this experience is presented. Either this or **site_area** is given but should not be both.
     */
    locations?: Array<(string)> | null;
    /**
     * Rules that define where the experience is gonna run. Either this or **locations** is given but should not be both.
     */
    site_area?: ((RuleObject) | null);
    /**
     * List of audiences IDs to which this experience is presented to
     */
    audiences?: Array<(string)> | null;
    /**
     * List of goals IDs to which will be tracked for this experience
     */
    goals?: Array<(string)>;
    /**
     * Only for multipage experience type
     */
    multipage_pages?: Array<MultipageExperiencePage>;
    status?: ExperienceStatuses;
    /**
     * Global Experience's JavaScript that will run for this experience before its changes are applied
     *
     */
    global_js?: string;
    /**
     * Global Experience's StyleSheet that will run for this experience before its changes are applied
     *
     */
    global_css?: string;
    type?: ExperienceTypes;
    /**
     * Experience's version number
     */
    version?: number;
    /**
     * Experience's variations list
     */
    variations?: Array<ExperienceVariationConfig>;
    /**
     * List of integrations that this experience's data is sent to
     */
    integrations?: Array<(ExperienceIntegrationBaidu | ExperienceIntegrationClicktale | ExperienceIntegrationClicky | ExperienceIntegrationCnzz | ExperienceIntegrationCrazyegg | ExperienceIntegrationEconda | ExperienceIntegrationEulerian | ExperienceIntegrationGAServing | ExperienceIntegrationGosquared | ExperienceIntegrationHeapanalytics | ExperienceIntegrationHotjar | ExperienceIntegrationMixpanel | ExperienceIntegrationMouseflow | ExperienceIntegrationPiwik | ExperienceIntegrationSegmentio | ExperienceIntegrationSitecatalyst | ExperienceIntegrationWoopra | ExperienceIntegrationYsance)>;
    /**
     * List of environments that this experience is supposed to run on. The full list of available environments is defined at
     * project level. If this list is empty, the experience will run on all environments.
     *
     * @deprecated
     */
    environments?: Array<(string)>;
    /**
     * The environment where this experience will run. It has to be one of the environments defined at the project level
     */
    environment?: string;
    /**
     * Various experience's settings
     */
    settings?: {
        /**
         * Minimum order value for transactions outliers
         * @deprecated
         */
        min_order_value?: number;
        /**
         * Maximum order value for transactions outliers
         * @deprecated
         */
        max_order_value?: number;
        /**
         * Various settings used by the stats engine to detect outliers
         */
        outliers?: {
            /**
             * Order value outlier settings
             */
            order_value?: (NumericOutlier);
            /**
             * Products Ordered count outlier settings
             */
            products_ordered_count?: (NumericOutlier);
        };
        /**
         * A couple of settings only applicable to Split URL experiments
         */
        split_url_settings?: {
            /**
             * Whether regular expressions are supported in original/variation URLs of a split URL experiment or not.
             *
             * It only applies to **experience_type** - **split_url**
             *
             */
            split_regex_support?: boolean;
        };
        /**
         * Various settings used for matching the list of Audiences and Locations
         */
        matching_options?: {
            audiences?: GenericListMatchingOptions;
            locations?: GenericListMatchingOptions;
        };
    };
};

/**
 * Multipage Experience Page object
 */
export type MultipageExperiencePage = {
    /**
     * The ID of the page.
     */
    id?: string;
    /**
     * Name of the page
     */
    name?: string;
    /**
     * The url of page to load
     */
    url?: string;
};

/**
 * Variation Object
 */
export type ExperienceVariationConfig = {
    /**
     * Variation ID
     */
    id?: string;
    /**
     * Variation name
     */
    name?: string;
    /**
     * Variation Key
     */
    key?: string;
    /**
     * Percentage of traffic allocation for this variation, as a number from 0 to 10000.
     * For an experience, the sum of the traffic allocations for all variations cannot be greater than 10000.
     *
     */
    traffic_allocation?: number;
    status?: VariationStatuses;
    /**
     * List of changes that this variation is exposing.
     */
    changes?: Array<ExperienceChangeServing>;
};

export type ExperienceStatuses = 'draft' | 'active' | 'paused' | 'completed' | 'scheduled';

export const ExperienceStatuses = {
    DRAFT: 'draft',
    ACTIVE: 'active',
    PAUSED: 'paused',
    COMPLETED: 'completed',
    SCHEDULED: 'scheduled'
} as const;

export type ExperienceTypes = 'a/b' | 'a/a' | 'mvt' | 'split_url' | 'multipage' | 'deploy';

export const ExperienceTypes = {
    A_B: 'a/b',
    A_A: 'a/a',
    MVT: 'mvt',
    SPLIT_URL: 'split_url',
    MULTIPAGE: 'multipage',
    DEPLOY: 'deploy'
} as const;

/**
 * Variation status
 */
export type VariationStatuses = 'stopped' | 'running';

/**
 * Variation status
 */
export const VariationStatuses = {
    STOPPED: 'stopped',
    RUNNING: 'running'
} as const;

export type ExperienceIntegrationGAServing = ExperienceIntegrationGA3 | ExperienceIntegrationGA4Base;

/**
 * Base Feature Object
 */
export type ConfigFeature = {
    /**
     * Feature ID
     */
    id?: string;
    /**
     * A name given to the feature to identify it easily
     */
    name?: string;
    /**
     * A unique per project level identifier
     */
    key?: string;
    /**
     * An array of user-defined variables of a feature.
     */
    variables?: Array<FeatureVariableItemData>;
};

/**
 * An object which describes the variable of a feature. Where key is variable name and value is one of the possible types [boolean, float, json, integer, string]
 */
export type FeatureVariableItemData = {
    /**
     * A user-defined variable name
     */
    key?: string;
    /**
     * A variable's type
     */
    type?: 'boolean' | 'float' | 'json' | 'integer' | 'string';
};

/**
 * A variable's type
 */
export type type10 = 'boolean' | 'float' | 'json' | 'integer' | 'string';

/**
 * A variable's type
 */
export const type10 = {
    BOOLEAN: 'boolean',
    FLOAT: 'float',
    JSON: 'json',
    INTEGER: 'integer',
    STRING: 'string'
} as const;

/**
 * Goal item to be tracked  inside a project
 */
export type ConfigGoalBase = {
    /**
     * Goal ID
     */
    id?: string;
    /**
     * Goal Name.
     */
    name?: string;
    /**
     * Goal Key
     */
    key?: string;
    /**
     * List of goal types to be returned
     */
    type?: Array<GoalTypes>;
    rules?: ((RuleObject) | null);
};

export type ConfigGoal = DomInteractionGoal | ScrollPercentageGoal | RevenueGoal | NoSettingsGoal | GaGoal | SubmitsFormGoal | ClicksLinkGoal | ClicksElementGoal;

export type DomInteractionGoal = ConfigGoalBase & {
    type?: 'dom_interaction';
    settings?: DomInteractionGoalSettings;
};

export type type11 = 'dom_interaction';

export const type11 = {
    DOM_INTERACTION: 'dom_interaction'
} as const;

export type ScrollPercentageGoal = ConfigGoalBase & {
    type?: 'scroll_percentage';
    settings?: ScrollPercentageGoalSettings;
};

export type type12 = 'scroll_percentage';

export const type12 = {
    SCROLL_PERCENTAGE: 'scroll_percentage'
} as const;

export type RevenueGoal = ConfigGoalBase & {
    type?: 'revenue';
    settings?: RevenueGoalSettings;
};

export type type13 = 'revenue';

export const type13 = {
    REVENUE: 'revenue'
} as const;

export type NoSettingsGoal = ConfigGoalBase & {
    type?: 'advanced' | 'visits_page' | 'code_trigger';
};

export type type14 = 'advanced' | 'visits_page' | 'code_trigger';

export const type14 = {
    ADVANCED: 'advanced',
    VISITS_PAGE: 'visits_page',
    CODE_TRIGGER: 'code_trigger'
} as const;

export type GaGoal = ConfigGoalBase & {
    type?: 'ga_import';
    settings?: GaGoalSettings;
};

export type type15 = 'ga_import';

export const type15 = {
    GA_IMPORT: 'ga_import'
} as const;

export type SubmitsFormGoal = ConfigGoalBase & {
    type?: 'submits_form';
    settings?: SubmitsFormGoalSettings;
};

export type type16 = 'submits_form';

export const type16 = {
    SUBMITS_FORM: 'submits_form'
} as const;

export type ClicksLinkGoal = ConfigGoalBase & {
    type?: 'clicks_link';
    settings?: ClicksLinkGoalSettings;
};

export type type17 = 'clicks_link';

export const type17 = {
    CLICKS_LINK: 'clicks_link'
} as const;

export type ClicksElementGoal = ConfigGoalBase & {
    type?: 'clicks_element';
    settings?: ClicksElementGoalSettings;
};

export type type18 = 'clicks_element';

export const type18 = {
    CLICKS_ELEMENT: 'clicks_element'
} as const;

export type DomInteractionGoalSettings = {
    /**
     * Array of Events to be tracked by this goal
     */
    tracked_items: Array<{
        /**
         * Css selector that identifies the DOM element(s) on which 'event' is to be monitored in order to fire the goal.
         */
        selector?: string;
        /**
         * The event to monitor in order to fire the goal.
         */
        event?: string;
    }>;
};

export type ScrollPercentageGoalSettings = {
    /**
     * The percentage of scrolling after which the goal will be fired
     */
    percentage: number;
};

export type GaGoalSettings = {
    /**
     * GA4 event name
     */
    ga_event?: string;
};

export type RevenueGoalSettings = {
    /**
     * Type of the revenue goal tracking, one of the below.
     * * "manual" - goal will be triggered through the given revenue tracking code;
     * An empty **triggering_rule** has to be provided as that takes priority over manual triggering
     * * "ga" - Convert will attempt to pick revenue from GA revenue tracking code and attach it to this goal,
     * when on page where this goal is triggered via "triggering_rule"
     *
     */
    triggering_type: 'manual' | 'ga';
};

/**
 * Type of the revenue goal tracking, one of the below.
 * * "manual" - goal will be triggered through the given revenue tracking code;
 * An empty **triggering_rule** has to be provided as that takes priority over manual triggering
 * * "ga" - Convert will attempt to pick revenue from GA revenue tracking code and attach it to this goal,
 * when on page where this goal is triggered via "triggering_rule"
 *
 */
export type triggering_type = 'manual' | 'ga';

/**
 * Type of the revenue goal tracking, one of the below.
 * * "manual" - goal will be triggered through the given revenue tracking code;
 * An empty **triggering_rule** has to be provided as that takes priority over manual triggering
 * * "ga" - Convert will attempt to pick revenue from GA revenue tracking code and attach it to this goal,
 * when on page where this goal is triggered via "triggering_rule"
 *
 */
export const triggering_type = {
    MANUAL: 'manual',
    GA: 'ga'
} as const;

export type SubmitsFormGoalSettings = {
    /**
     * Url representing form's action attribute used to identify forms which will be tracked for submit event.
     */
    action: string;
};

export type ClicksLinkGoalSettings = {
    /**
     * Url representing link's href attribute used to identify links which will be tracked for click event
     */
    href: string;
};

export type ClicksElementGoalSettings = {
    /**
     * Css selector that identifies the DOM element(s) on which will track clicks in order to fire the goal.
     */
    selector: string;
};

/**
 * Goals type, one of below.
 */
export type GoalTypes = 'advanced' | 'dom_interaction' | 'scroll_percentage' | 'code_trigger' | 'revenue';

/**
 * Goals type, one of below.
 */
export const GoalTypes = {
    ADVANCED: 'advanced',
    DOM_INTERACTION: 'dom_interaction',
    SCROLL_PERCENTAGE: 'scroll_percentage',
    CODE_TRIGGER: 'code_trigger',
    REVENUE: 'revenue'
} as const;

/**
 * Defines how and when an experience associated with this location should be activated for a visitor who matches the location's rules.
 * The `type` determines the activation mechanism.
 * Knowledge Base: "Locations" - "Dynamic Website Triggers".
 *
 */
export type LocationTrigger = LocationTriggerDomElement | LocationTriggerCallback | LocationTriggerManual | LocationTriggerUponRun;

/**
 * Specifies the mechanism that activates an experience when its location rules are met:
 * - `upon_run`: (Default) The experience activates as soon as the Convert tracking script loads and evaluates that the visitor matches the location's rules (e.g., URL match). This is the standard behavior for most A/B tests.
 * - `manual`: The experience only activates when explicitly triggered by a JavaScript call (`window._conv_q.push({ what: 'triggerLocation', params: { locationId: '...' } })`). Gives precise programmatic control over activation.
 * - `dom_element`: The experience activates upon a specific user interaction (e.g., 'click', 'hover', 'in_view', 'change') with a defined DOM element (identified by a CSS `selector`). Useful for testing changes related to interactive elements.
 * - `callback`: The experience activates when a custom JavaScript `callback` function (provided in `js`) calls the `activate()` function passed to it. Allows for complex asynchronous activation logic, e.g., after an API response or a specific SPA state change.
 * Note: For Full Stack projects, `upon_run` is effectively the only mode, as activation is handled by the SDK.
 *
 */
export type LocationTriggerTypes = 'upon_run' | 'manual' | 'dom_element' | 'callback';

/**
 * Specifies the mechanism that activates an experience when its location rules are met:
 * - `upon_run`: (Default) The experience activates as soon as the Convert tracking script loads and evaluates that the visitor matches the location's rules (e.g., URL match). This is the standard behavior for most A/B tests.
 * - `manual`: The experience only activates when explicitly triggered by a JavaScript call (`window._conv_q.push({ what: 'triggerLocation', params: { locationId: '...' } })`). Gives precise programmatic control over activation.
 * - `dom_element`: The experience activates upon a specific user interaction (e.g., 'click', 'hover', 'in_view', 'change') with a defined DOM element (identified by a CSS `selector`). Useful for testing changes related to interactive elements.
 * - `callback`: The experience activates when a custom JavaScript `callback` function (provided in `js`) calls the `activate()` function passed to it. Allows for complex asynchronous activation logic, e.g., after an API response or a specific SPA state change.
 * Note: For Full Stack projects, `upon_run` is effectively the only mode, as activation is handled by the SDK.
 *
 */
export const LocationTriggerTypes = {
    UPON_RUN: 'upon_run',
    MANUAL: 'manual',
    DOM_ELEMENT: 'dom_element',
    CALLBACK: 'callback'
} as const;

export type LocationTriggerBase = {
    type: LocationTriggerTypes;
};

export type LocationTriggerUponRun = LocationTriggerBase & {
    type?: 'upon_run';
};

export type type19 = 'upon_run';

export const type19 = {
    UPON_RUN: 'upon_run'
} as const;

export type LocationTriggerManual = LocationTriggerBase & {
    type?: 'manual';
};

export type type20 = 'manual';

export const type20 = {
    MANUAL: 'manual'
} as const;

/**
 * The type of user interaction with a DOM element that will trigger the experience:
 * - `click`: Activates when the element is clicked.
 * - `hover`: Activates when the mouse pointer hovers over the element (mouseenter).
 * - `in_view`: Activates when the element becomes visible in the browser's viewport (e.g., user scrolls to it). KB: "Launch Experiments Using Custom JavaScript When Elements Appear in DOM".
 * - `change`: Activates when the value of a form element (like input, select, textarea) changes.
 *
 */
export type LocationDomTriggerEvents = 'click' | 'hover' | 'in_view' | 'change';

/**
 * The type of user interaction with a DOM element that will trigger the experience:
 * - `click`: Activates when the element is clicked.
 * - `hover`: Activates when the mouse pointer hovers over the element (mouseenter).
 * - `in_view`: Activates when the element becomes visible in the browser's viewport (e.g., user scrolls to it). KB: "Launch Experiments Using Custom JavaScript When Elements Appear in DOM".
 * - `change`: Activates when the value of a form element (like input, select, textarea) changes.
 *
 */
export const LocationDomTriggerEvents = {
    CLICK: 'click',
    HOVER: 'hover',
    IN_VIEW: 'in_view',
    CHANGE: 'change'
} as const;

export type LocationTriggerDomElement = LocationTriggerBase & {
    type?: 'dom_element';
    /**
     * Describes html selector
     */
    selector: string;
    /**
     * Events for LocationTriggerDomElement
     */
    events: Array<LocationDomTriggerEvents>;
};

export type type21 = 'dom_element';

export const type21 = {
    DOM_ELEMENT: 'dom_element'
} as const;

export type LocationTriggerCallback = LocationTriggerBase & {
    type?: 'callback';
    /**
     * Describes the js callback that will be executed in order to fire the experience.
     *
     * It is called with two arguments:
     * - `activate` - a function that should be called when the experience should be activated
     * - `options` - an object with the following properties:
     * - `locationId` - id of the location that is being activated
     * - `isActive` - boolean flag that indicates if the location is active
     * Example:
     * ```
     * function(activate, options) {
     * if (options.isActive) {
     * setTimeout(function() {
     * * it activates the experiences 1 second after the
     * location trigger is initialized - at the load of the tracking script *
     * activate();
     * }, 1000);
     * }
     * }
     * ```
     *
     */
    js: string;
};

export type type22 = 'callback';

export const type22 = {
    CALLBACK: 'callback'
} as const;

/**
 * Base Location object
 */
export type ConfigLocation = {
    /**
     * Location ID
     */
    id?: string;
    /**
     * Location unique key
     */
    key?: string;
    /**
     * Location Name
     */
    name?: string;
    trigger?: LocationTrigger;
    rules?: ((RuleObject) | null);
};

export type ConfigProjectMinimalSettings = {
    /**
     * Whether to include jQuery library or not into the javascript tracking file served by Convert and loaded via the tracking snippet. If jQuery is not included, it has to be loaded on page, before Convert's tracking code
     */
    include_jquery?: boolean;
    /**
     * Whether to include jQuery library or not into the v1 javascript tracking file served by Convert and loaded via the tracking snippet.
     */
    include_jquery_v1?: boolean;
    /**
     * Whether to disable the SPA (Single Page Application) related functionalities from the tracking scripts V1. Most websites work fine without disabling SPA functionality regardless of the fact they are Single Page Apps or not. In edge situation, this setting might prove handy
     */
    disable_spa_functionality?: boolean;
    /**
     * Tracks the project's version, updated with each change done inside the project, which would affect the config of that project. The format is [ISO_datetime]-[incremental_number].
     *
     */
    readonly version?: (string) | null;
    tracking_script?: TrackingScriptReleaseBase;
};

/**
 * Project Object under which experiences would get created
 */
export type ConfigProject = {
    /**
     * Project ID
     */
    id?: string;
    /**
     * Project Name. If **settings.data_anonymization** is turned on, the name will be generated from **id** field
     */
    name?: string;
    /**
     * Value which describes project product type
     */
    type?: 'fullstack' | 'web';
    utc_offset?: UTC_Offset;
    /**
     * Object representing the custom domain that is used for loading the tracking scripts and
     * sending tracking requests to Convert servers instead of the standard Convert domain
     *
     */
    custom_domain?: {
        /**
         * Custom domain to be used instead of standard Convert's one
         */
        domain?: string;
    } | null;
    /**
     * List of domains allowed to be tracked under this project
     */
    domains?: Array<{
        /**
         * Top level domain, used for setting cookies where applicable
         */
        tld?: string;
        /**
         * List of host names under **tld** which are allowed to be tracked under this project
         */
        hosts?: unknown;
    }>;
    /**
     * The global javascript code that will be loaded on all pages where
     * the tracking script is installed, prior to processing any of
     * experiences, goals, audiences etc. When an environment is specified in the request,
     * this will be combined with the environment-specific global_js (if any) by appending
     * the environment's code with a newline character.
     *
     */
    global_javascript?: (string) | null;
    settings?: ({
    /**
     * Flag indicating whether decoration of outgoing links (appending tracking cookies inside the link URL in order to
     * make cross domain tracking possible) is done automatically on page
     *
     */
    allow_crossdomain_tracking?: boolean;
    /**
     * Whether or not data is [anonymized](https://convert.zendesk.com/hc/en-us/articles/204506339-Prevent-Experiment-Details-Data-Leak-with-Data-Anonymization).
     */
    data_anonymization?: boolean;
    /**
     * Follow the 'Do not track' browser settings for users in the mentioned area of the world.
     */
    do_not_track?: 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';
    /**
     * Follow Global Privacy Control (GPC) signals for users in the mentioned area of the world.
     * - OFF: Do not follow GPC signals.
     * - EU ONLY: Follow GPC signals for users in the European Union only.
     * - EEA ONLY: Follow GPC signals for users in the European Economic Area only.
     * - Worldwide: Follow GPC signals for users worldwide.
     *
     */
    global_privacy_control?: 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';
    /**
     * When this is turned to true, Convert won't track any referral data like http referral, utm query strings etc. Those will be used on the current page if available but won't be stored in cookies in order to be used on subsequent pages.
     */
    do_not_track_referral?: boolean;
    /**
     * This holds project wide settings used by integrations
     */
    integrations?: {
        google_analytics?: GA_Settings;
        visitor_insights?: {
            tracking_id?: VisitorInsightsTrackingId;
        };
        kissmetrics?: {
            /**
             * Flag indicating whether Kissmetrics integration is enabled or not for this project
             */
            enabled?: boolean;
        };
    };
    /**
     * Minimum order value for transactions outliers
     * @deprecated
     */
    min_order_value?: number;
    /**
     * Maximum order value for transactions outliers
     * @deprecated
     */
    max_order_value?: number;
    /**
     * Various settings used by the stats engine to detect outliers
     */
    outliers?: {
        /**
         * Order value outlier settings
         */
        order_value?: (NumericOutlier);
        /**
         * Products Ordered count outlier settings
         */
        products_ordered_count?: (NumericOutlier);
    };
} & ConfigProjectMinimalSettings);
};

/**
 * Value which describes project product type
 */
export type type23 = 'fullstack' | 'web';

/**
 * Value which describes project product type
 */
export const type23 = {
    FULLSTACK: 'fullstack',
    WEB: 'web'
} as const;

/**
 * Follow the 'Do not track' browser settings for users in the mentioned area of the world.
 */
export type do_not_track = 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';

/**
 * Follow the 'Do not track' browser settings for users in the mentioned area of the world.
 */
export const do_not_track = {
    OFF: 'OFF',
    EU_ONLY: 'EU ONLY',
    EEA_ONLY: 'EEA ONLY',
    WORLDWIDE: 'Worldwide'
} as const;

/**
 * Follow Global Privacy Control (GPC) signals for users in the mentioned area of the world.
 * - OFF: Do not follow GPC signals.
 * - EU ONLY: Follow GPC signals for users in the European Union only.
 * - EEA ONLY: Follow GPC signals for users in the European Economic Area only.
 * - Worldwide: Follow GPC signals for users worldwide.
 *
 */
export type global_privacy_control = 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';

/**
 * Follow Global Privacy Control (GPC) signals for users in the mentioned area of the world.
 * - OFF: Do not follow GPC signals.
 * - EU ONLY: Follow GPC signals for users in the European Union only.
 * - EEA ONLY: Follow GPC signals for users in the European Economic Area only.
 * - Worldwide: Follow GPC signals for users worldwide.
 *
 */
export const global_privacy_control = {
    OFF: 'OFF',
    EU_ONLY: 'EU ONLY',
    EEA_ONLY: 'EEA ONLY',
    WORLDWIDE: 'Worldwide'
} as const;

/**
 * Settings to identify which tracking script version will be applied to the project.
 */
export type TrackingScriptReleaseBase = {
    /**
     * Current version of the tracking script bundle
     */
    readonly current_version?: string;
    /**
     * Latest available version of the tracking script bundle.
     */
    readonly latest_version?: (string) | null;
} | null;

/**
 * The tracking ID for Visitor Insights.
 */
export type VisitorInsightsTrackingId = string;

export type VisitorInsightsData = VisitorInsightsBase & {
    tracking_id?: VisitorInsightsTrackingId;
    /**
     * The sampling rate for tracking events.
     */
    sampling_rate?: number;
};

export type ProjectGASettingsBase = GA_SettingsBase & {
    /**
     * Attempt to pull revenue data from Google Analytics Revenue Tracking code.
     */
    auto_revenue_tracking?: boolean;
};

export type ProjectIntegrationGA3 = ProjectGASettingsBase & IntegrationGA3;

export type ProjectIntegrationGA4 = ProjectGASettingsBase & IntegrationGA4Base & {
    /**
     * Boolean indicating whether to wait for the page view event to complete before sending other events.
     */
    no_wait_pageview?: boolean;
};

export type GA_Settings = ProjectIntegrationGA3 | ProjectIntegrationGA4;

/**
 * Base Segment object
 */
export type ConfigSegment = {
    /**
     * Segment ID
     */
    id?: string;
    /**
     * Segment unique key
     */
    key?: string;
    /**
     * Segment Name
     */
    name?: string;
    rules?: ((RuleObject) | null);
};

/**
 * Tracking Request's data
 */
export type SendTrackingEventsRequestData = {
    /**
     * ID of the account under which the project is setup
     */
    accountId?: string;
    /**
     * ID of the project under which the tracking occurs
     */
    projectId?: string;
    /**
     * Flag to determine whether the data is gonna be enriched before the events are stored for reporting.
     * For example, in case of a conversion event, if this flag is on and bucketing is not provided, the bucketing stored on the backend datastore for the given visitor
     * ID would be used. Same applies for segments.
     *
     * *Note*: this flag is only available for some plans
     *
     */
    enrichData?: boolean;
    /**
     * List of visitors tracked. Each visitor can have multiple events.
     *
     */
    visitors?: Array<{
        segments?: VisitorSegments;
        /**
         * Id of the visitor tracked
         */
        visitorId?: string;
        /**
         * List of events fired for the given visitor
         */
        events?: Array<VisitorTrackingEvents>;
    }>;
};

/**
 * Tracking events related to the same user ID
 */
export type VisitorTrackingEvents = {
    /**
     * Type of the event. It can be a bucketing or a conversion event
     */
    eventType?: 'bucketing' | 'conversion';
    data?: (BucketingEvent | ConversionEvent);
};

/**
 * Type of the event. It can be a bucketing or a conversion event
 */
export type eventType = 'bucketing' | 'conversion';

/**
 * Type of the event. It can be a bucketing or a conversion event
 */
export const eventType = {
    BUCKETING: 'bucketing',
    CONVERSION: 'conversion'
} as const;

/**
 * Bucketing event data
 */
export type BucketingEvent = {
    /**
     * Experience ID to which the visitor is bucketed. In case that **enrichData=true** flag is being sent, only unique events are gonna be recorded. Otherwise, it's
     * up to the client to ensure that duplicates of the same event for the same visitor do not get sent to the tracking endpoint.
     *
     */
    experienceId: string;
    /**
     * Variation ID corresponding to the experience identified by experienceID, that is assigned to the visitor.
     */
    variationId: string;
};

/**
 * Conversion event data
 */
export type ConversionEvent = {
    /**
     * Id of the conversion goal to be fired
     */
    goalId: string;
    /**
     * Data connected to this conversion, for non binomial metrics, eg revenue
     */
    goalData?: Array<{
        /**
         * Key of the metric
         */
        key?: 'amount' | 'productsCount' | 'transactionId' | 'customDimension1' | 'customDimension2' | 'customDimension3' | 'customDimension4' | 'customDimension5';
        /**
         * Value of the metric
         */
        value?: (number | string | Array<(string)>);
    }>;
    /**
     * Bucketing data (experiences that this visitor is currently part of) for the visitor. In case that **enrichData=true** flag is being sent and
     * this attribute is not provided, the bucketing stored on the backend datastore for the given visitor is gonna be used. If both **enrichData=true** and
     * **bucketingData**, the **bucketingData** is gonna be merged with the stored data inside the backend data source, the request provided data having the
     * biggest overwriting bucketing for the same experience which might exist on the backend
     *
     */
    bucketingData?: {
        [key: string]: (string);
    };
};

/**
 * Segments under which this visitor is placed. Some defaults keys are accepted and any other free field **key value** could be used
 * for fullstack projects
 *
 */
export type VisitorSegments = {
    /**
     * Browser used:
     * IE - Internet Explorer
     * CH - Chrome
     * FF - Firefox
     * OP - Opera
     * SF - Safari
     * OTH - Other
     *
     */
    browser?: 'IE' | 'CH' | 'FF' | 'OP' | 'SF' | 'OTH';
    /**
     * List of device classes that the visitor device falls into
     */
    devices?: Array<('ALLPH' | 'IPH' | 'OTHPH' | 'ALLTAB' | 'IPAD' | 'OTHTAB' | 'DESK' | 'OTHDEV')>;
    /**
     * Traffic source
     */
    source?: 'campaign' | 'search' | 'referral' | 'direct';
    /**
     * Campaign string
     */
    campaign?: string;
    /**
     * Type of the visitor
     */
    visitorType?: 'new' | 'returning';
    /**
     * Two ISO country code for visitor's country
     */
    country?: string;
    /**
     * Custom Segments as defined inside Convert app. This will be the list of segments' IDs
     */
    customSegments?: Array<(string)>;
};

/**
 * Browser used:
 * IE - Internet Explorer
 * CH - Chrome
 * FF - Firefox
 * OP - Opera
 * SF - Safari
 * OTH - Other
 *
 */
export type browser = 'IE' | 'CH' | 'FF' | 'OP' | 'SF' | 'OTH';

/**
 * Browser used:
 * IE - Internet Explorer
 * CH - Chrome
 * FF - Firefox
 * OP - Opera
 * SF - Safari
 * OTH - Other
 *
 */
export const browser = {
    IE: 'IE',
    CH: 'CH',
    FF: 'FF',
    OP: 'OP',
    SF: 'SF',
    OTH: 'OTH'
} as const;

/**
 * Traffic source
 */
export type source = 'campaign' | 'search' | 'referral' | 'direct';

/**
 * Traffic source
 */
export const source = {
    CAMPAIGN: 'campaign',
    SEARCH: 'search',
    REFERRAL: 'referral',
    DIRECT: 'direct'
} as const;

/**
 * Type of the visitor
 */
export type visitorType = 'new' | 'returning';

/**
 * Type of the visitor
 */
export const visitorType = {
    NEW: 'new',
    RETURNING: 'returning'
} as const;

export type GetProjectConfigData = {
    /**
     * ID of the account that owns the retrieved/saved data
     */
    accountId: number;
    /**
     * Filter experiences based on environment.
     */
    environment?: string;
    /**
     * ID of the project to be retrieved
     */
    projectId: number;
};

export type GetProjectConfigResponse = (ConfigResponseData);

export type GetProjectConfigBySdkKeyData = {
    /**
     * Filter experiences based on environment.
     */
    environment?: string;
    /**
     * The SDK key used to retrieve the project's config
     */
    sdkKey: string;
};

export type GetProjectConfigBySdkKeyResponse = (ConfigResponseData);

export type GetProjectSettingsData = {
    /**
     * ID of the account that owns the retrieved/saved data
     */
    accountId: number;
    /**
     * ID of the project to be retrieved
     */
    projectId: number;
};

export type GetProjectSettingsResponse = (ConfigMinimalResponseData);

export type GetProjectOptionalSettingsData = {
    /**
     * ID of the account that owns the retrieved/saved data
     */
    accountId: number;
    /**
     * ID of the project to be retrieved
     */
    projectId: number;
};

export type GetProjectOptionalSettingsResponse = (ConfigOptionalResponseData);

export type SendTrackingEventsSdkKeyData = {
    /**
     * A JSON object containing the tracking events sent to the Convert tracking servers.
     */
    requestBody: SendTrackingEventsRequestData;
    /**
     * The SDK key used to identify the project where that the data belongs to
     */
    sdkKey: string;
};

export type SendTrackingEventsSdkKeyResponse = (SuccessData);

export type SendTrackingEventsData = {
    /**
     * ID of the account that owns the given project
     */
    accountId: number;
    /**
     * ID of the project to which the events belong to
     */
    projectId: number;
    /**
     * A JSON object containing the tracking events sent to the Convert tracking servers.
     */
    requestBody: SendTrackingEventsRequestData;
};

export type SendTrackingEventsResponse = (SuccessData);

export type $OpenApiTs = {
    '/config/{account_id}/{project_id}': {
        get: {
            req: GetProjectConfigData;
            res: {
                /**
                 * Object consumed by SDKs
                 *
                 */
                200: ConfigResponseData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/config/{sdk_key}': {
        get: {
            req: GetProjectConfigBySdkKeyData;
            res: {
                /**
                 * Object consumed by SDKs
                 *
                 */
                200: ConfigResponseData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/project-settings/{account_id}/{project_id}': {
        get: {
            req: GetProjectSettingsData;
            res: {
                /**
                 * Object consumed by SDKs
                 *
                 */
                200: ConfigMinimalResponseData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/project-optional-settings/{account_id}/{project_id}': {
        get: {
            req: GetProjectOptionalSettingsData;
            res: {
                /**
                 * Object consumed by SDKs
                 *
                 */
                200: ConfigOptionalResponseData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/track/{sdk_key}': {
        post: {
            req: SendTrackingEventsSdkKeyData;
            res: {
                /**
                 * A response signaling a generic success
                 */
                200: SuccessData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/track/{account_id}/{project_id}': {
        post: {
            req: SendTrackingEventsData;
            res: {
                /**
                 * A response signaling a generic success
                 */
                200: SuccessData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
};